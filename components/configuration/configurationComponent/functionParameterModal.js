import { optimizeJsonApi, updateFlowDescription } from "@/config";
import { useCustomSelector } from "@/customHooks/customSelector";
import { parameterTypes } from "@/jsonFiles/bridgeParameter";
import {
  updateApiAction,
  updateBridgeVersionAction,
  updateFuntionApiAction,
} from "@/store/action/bridgeAction";
import { closeModal, flattenParameters } from "@/utils/utility";
import { isEqual } from "lodash";
import { CopyIcon, InfoIcon, TrashIcon, PencilIcon, CloseIcon, AddIcon, ChevronDownIcon, ChevronRightIcon } from "@/components/Icons";
import React, { useEffect, useMemo, useState } from "react";
import { useDispatch } from "react-redux";
import { toast } from "react-toastify";

function FunctionParameterModal({ preFunction, functionId, params, Model_Name, embedToken }) {
  const [isLoading, setIsLoading] = useState(false);
  const [isDescriptionEditing, setIsDescriptionEditing] = useState(false);
  const [expandedObjects, setExpandedObjects] = useState({});
  const dispatch = useDispatch();
  
  const { function_details, variables_path } = useCustomSelector((state) => ({
    function_details:
      state?.bridgeReducer?.org?.[params?.org_id]?.functionData?.[functionId] || {},
    variables_path:
      state?.bridgeReducer?.bridgeVersionMapping?.[params?.id]?.[
        params?.version
      ]?.variables_path || {},
  }));

  const functionName = useMemo(
    () => function_details["endpoint"] || function_details["function_name"],
    [function_details]
  );

  const properties = function_details.fields || {};
  const [toolData, setToolData] = useState(function_details || {});
  const [variablesPath, setVariablesPath] = useState(
    variables_path[functionName] || {}
  );
  const [isDataAvailable, setIsDataAvailable] = useState(
    Object.keys(properties).length > 0
  );
  const [isModified, setIsModified] = useState(false);
  const [objectFieldValue, setObjectFieldValue] = useState("");
  const [isTextareaVisible, setIsTextareaVisible] = useState(false);
  const [isOldFieldViewTrue, setIsOldFieldViewTrue] = useState(false);

  const flattenedParameters = flattenParameters(toolData?.fields).filter(param => 
    !param.key.includes('.')
  );

  useEffect(() => {
    setToolData(function_details);
    setIsDataAvailable(Object.keys(properties).length > 0);
  }, [function_details, properties]);

  useEffect(() => {
    setVariablesPath(variables_path[functionName] || {});
  }, [variables_path, functionName]);

  useEffect(() => {
    const toolDataChanged = !isEqual(toolData, function_details);
    const variablesPathChanged = !isEqual(variablesPath, variables_path[functionName] || {});
    setIsModified(toolDataChanged || variablesPathChanged);
  }, [toolData, function_details, variablesPath, variables_path, functionName]);

  const toggleObjectExpansion = (paramKey) => {
    setExpandedObjects(prev => ({
      ...prev,
      [paramKey]: !prev[paramKey]
    }));
  };

  const generateUniqueNestedParameterName = (objectKey) => {
    const objectField = getNestedFieldValue(toolData.fields, objectKey.split("."));
    const existingNestedParams = Object.keys(objectField?.parameter || {});
    const newParams = existingNestedParams.filter(name => /^new\d+$/.test(name));
    const numbers = newParams.map(name => parseInt(name.replace('new', ''), 10));
    const maxNumber = numbers.length > 0 ? Math.max(...numbers) : 0;
    return `new${maxNumber + 1}`;
  };

  const handleAddNestedParameter = (objectKey) => {
    const autoGeneratedName = generateUniqueNestedParameterName(objectKey);
    
    setToolData(prevToolData => {
      const updatedFields = updateField(
        prevToolData.fields,
        objectKey.split("."),
        (field) => {
          const currentParameter = field?.parameter || {};
          return {
            ...field,
            parameter: {
              ...currentParameter,
              [autoGeneratedName]: {
                type: "string",
                description: "",
                enum: [],
                required_params: [],
                parameter: {}
              }
            }
          };
        }
      );

      return {
        ...prevToolData,
        fields: updatedFields
      };
    });

    if (isTextareaVisible) {
      try {
        const currentFields = JSON.parse(objectFieldValue || '{}');
        let targetObject = currentFields;
        const keyParts = objectKey.split(".");
        
        for (const part of keyParts) {
          if (targetObject[part]) {
            if (targetObject[part].type === 'object') {
              targetObject = targetObject[part].parameter = targetObject[part].parameter || {};
            }
          }
        }
        
        const finalKey = keyParts[keyParts.length - 1];
        if (currentFields[finalKey] && currentFields[finalKey].type === 'object') {
          currentFields[finalKey].parameter = currentFields[finalKey].parameter || {};
          currentFields[finalKey].parameter[autoGeneratedName] = {
            type: "string",
            description: "",
            enum: [],
            required_params: [],
            parameter: {}
          };
        }
        
        setObjectFieldValue(JSON.stringify(currentFields, null, 4));
      } catch (error) {
        console.error("Error updating JSON view:", error);
      }
    }

    toast.success(`Nested parameter "${autoGeneratedName}" added to ${objectKey}`);
  };

  const getNestedParameters = (objectKey) => {
    const objectField = getNestedFieldValue(toolData.fields, objectKey.split("."));
    const nestedParams = objectField?.parameter || {};
    
    return Object.keys(nestedParams).map(key => ({
      key: key,
      fullKey: `${objectKey}.${key}`,
      type: nestedParams[key].type,
      description: nestedParams[key].description,
      enum: nestedParams[key].enum,
      required: objectField?.required_params?.includes(key) || false
    }));
  };

  const handleNestedParameterNameChange = (parentKey, oldName, newName) => {
    if (!newName.trim()) {
      toast.error("Parameter name cannot be empty");
      return false;
    }

    if (oldName === newName) {
      return true;
    }

    const nestedParams = getNestedParameters(parentKey);
    const existingNames = nestedParams.map(p => p.key);
    
    if (existingNames.includes(newName)) {
      toast.error("Parameter name already exists in this object");
      return false;
    }

    setToolData(prev => {
      const updatedFields = { ...prev.fields };
      const parentField = getNestedFieldValue(updatedFields, parentKey.split('.'));
      
      if (parentField?.parameter?.[oldName]) {
        parentField.parameter[newName] = { ...parentField.parameter[oldName] };
        delete parentField.parameter[oldName];
        
        if (parentField.required_params?.includes(oldName)) {
          parentField.required_params = parentField.required_params.map(
            p => p === oldName ? newName : p
          );
        }
      }
      
      return {
        ...prev,
        fields: updatedFields
      };
    });

    if (isTextareaVisible) {
      try {
        const currentFields = JSON.parse(objectFieldValue);
        const parentKeyParts = parentKey.split('.');
        let targetObject = currentFields;
        
        for (const part of parentKeyParts) {
          if (targetObject[part] && targetObject[part].type === 'object') {
            targetObject = targetObject[part].parameter = targetObject[part].parameter || {};
          }
        }
        
        if (targetObject[oldName]) {
          targetObject[newName] = { ...targetObject[oldName] };
          delete targetObject[oldName];
        }
        
        setObjectFieldValue(JSON.stringify(currentFields, null, 4));
      } catch (error) {
        console.error("Error updating JSON view:", error);
      }
    }

    toast.success(`Parameter renamed from "${oldName}" to "${newName}"`);
    return true;
  };

  const copyToClipboard = (content) => {
    navigator.clipboard
      .writeText(content)
      .then(() => {
        toast.success("Content copied to clipboard");
      })
      .catch((error) => {
        console.error("Error copying content to clipboard:", error);
      });
  };

  const copyToolCallFormat = () => {
    const toolCallFormat = {
      type: "function",
      function: {
        name: function_details?.["function_name"],
        description:
          (function_details?.["endpoint_name"]
            ? "Name: " + function_details["endpoint_name"] + ", "
            : "") +
          "Description: " +
          function_details?.["description"],
        parameters: {
          type: "object",
          properties: JSON.parse(objectFieldValue) || {},
          required_params: function_details?.["required_params"] || [],
          additionalProperties: false,
        },
      },
    };
    copyToClipboard(JSON.stringify(toolCallFormat, undefined, 4));
  };

  const handleRequiredChange = (key) => {
    const keyParts = key.split(".");
    if (keyParts.length === 1) {
      setToolData((prevToolData) => {
        const updatedRequiredParams = prevToolData.required_params || [];
        const newRequiredParams = updatedRequiredParams.includes(keyParts[0])
          ? updatedRequiredParams.filter((item) => item !== keyParts[0])
          : [...updatedRequiredParams, keyParts[0]];

        return {
          ...prevToolData,
          required_params: newRequiredParams,
        };
      });
    } else {
      setToolData((prevToolData) => {
        const updatedFields = updateField(
          prevToolData.fields,
          keyParts.slice(0, -1),
          (field) => {
            if (!field) {
              console.warn(
                `Field not found for key: ${keyParts.slice(0, -1).join(".")}`
              );
              return {};
            }

            const fieldKey = keyParts[keyParts.length - 1];
            const updatedRequiredParams = field.required_params || [];
            const newRequiredParams = updatedRequiredParams.includes(fieldKey)
              ? updatedRequiredParams.filter((item) => item !== fieldKey)
              : [...updatedRequiredParams, fieldKey];

            return {
              ...field,
              required_params: newRequiredParams,
            };
          }
        );

        return {
          ...prevToolData,
          fields: updatedFields,
        };
      });
    }
  };

  const handleParameterNameChange = (oldKey, newName) => {
    if (!newName.trim()) {
      toast.error("Parameter name cannot be empty");
      return false;
    }

    if (oldKey === newName) {
      return true;
    }

    const existingKeys = flattenedParameters.map(param => param.key);
    if (existingKeys.includes(newName)) {
      toast.error("Parameter name already exists");
      return false;
    }

    const keyParts = oldKey.split(".");
    
    setToolData((prevToolData) => {
      const newFields = JSON.parse(JSON.stringify(prevToolData.fields));
      
      if (keyParts.length === 1) {
        if (newFields[oldKey]) {
          newFields[newName] = { ...newFields[oldKey] };
          delete newFields[oldKey];
          
          const updatedRequiredParams = (prevToolData.required_params || [])
            .map(param => param === oldKey ? newName : param);
          
          return {
            ...prevToolData,
            fields: newFields,
            required_params: updatedRequiredParams
          };
        }
      } else {
        toast.error("Nested parameter renaming is not supported yet");
        return prevToolData;
      }
      
      return {
        ...prevToolData,
        fields: newFields
      };
    });

    setVariablesPath(prevPaths => {
      const newPaths = { ...prevPaths };
      if (oldKey in newPaths) {
        newPaths[newName] = newPaths[oldKey];
        delete newPaths[oldKey];
      }
      return newPaths;
    });

    if (isTextareaVisible) {
      try {
        const currentFields = JSON.parse(objectFieldValue);
        if (currentFields[oldKey]) {
          currentFields[newName] = { ...currentFields[oldKey] };
          delete currentFields[oldKey];
          setObjectFieldValue(JSON.stringify(currentFields, undefined, 4));
        }
      } catch (error) {
        console.error("Error updating JSON view:", error);
      }
    }

    toast.success(`Parameter renamed from "${oldKey}" to "${newName}"`);
    return true;
  };

  const handleDescriptionChange = (key, newDescription) => {
    setToolData((prevToolData) => {
      const updatedFields = updateField(
        prevToolData.fields,
        key.split("."),
        (field) => ({
          ...field,
          description: newDescription,
        })
      );
      return {
        ...prevToolData,
        fields: updatedFields,
      };
    });
  };

  const updateField = (fields, keyParts, updateFn) => {
    const fieldClone = JSON.parse(JSON.stringify(fields));

    const _updateField = (currentFields, remainingKeyParts) => {
      if (remainingKeyParts.length === 1) {
        currentFields[remainingKeyParts[0]] = updateFn(
          currentFields[remainingKeyParts[0]]
        );
      } else {
        const [head, ...tail] = remainingKeyParts;
        if (currentFields[head]) {
          const isArray = currentFields[head].type === "array";
          const nestedKey = isArray ? "items" : "parameter";
          currentFields[head][nestedKey] = _updateField(
            currentFields[head][nestedKey] || {},
            tail
          );
        }
      }
      return currentFields;
    };

    return _updateField(fieldClone, keyParts);
  };

  const resetModalData = () => {
    setToolData(function_details);
    setVariablesPath(variables_path[functionName] || {});
    setObjectFieldValue("");
    setIsTextareaVisible(false);
    setIsDescriptionEditing(false);
    setExpandedObjects({});
  };

  const handleCloseModal = () => {
    resetModalData();
    closeModal(Model_Name);
  };

  const handleTypeChange = (key, newType) => {
    setToolData((prevToolData) => {
      const updatedFields = updateField(prevToolData.fields, key.split("."), (field) => {
        const updatedField = {
          ...field,
          type: newType,
          description: field.description || "",
          enum: field.enum || [],
          required_params: field.required_params || []
        };

        if (newType === "array") {
          return {
            ...updatedField,
            items: field.items || { type: "string" },
            parameter: undefined
          };
        } else if (newType === "object") {
          return {
            ...updatedField,
            parameter: field.parameter || {},
            items: undefined
          };
        } else {
          return {
            ...updatedField,
            parameter: undefined,
            items: undefined
          };
        }
      });

      return {
        ...prevToolData,
        fields: updatedFields
      };
    });

    if (isTextareaVisible) {
      try {
        const currentFields = JSON.parse(objectFieldValue || '{}');
        const keyParts = key.split('.');
        let targetObject = currentFields;
        
        for (let i = 0; i < keyParts.length - 1; i++) {
          const part = keyParts[i];
          if (targetObject[part]) {
            if (targetObject[part].type === 'object') {
              targetObject = targetObject[part].parameter || {};
            } else if (targetObject[part].type === 'array') {
              targetObject = targetObject[part].items || {};
            }
          }
        }
        
        const fieldKey = keyParts[keyParts.length - 1];
        if (targetObject[fieldKey]) {
          targetObject[fieldKey] = {
            ...targetObject[fieldKey],
            type: newType
          };
          
          if (newType === 'array') {
            targetObject[fieldKey].items = { type: 'string' };
            delete targetObject[fieldKey].parameter;
          } else if (newType === 'object') {
            targetObject[fieldKey].parameter = targetObject[fieldKey].parameter || {};
            delete targetObject[fieldKey].items;
          } else {
            delete targetObject[fieldKey].parameter;
            delete targetObject[fieldKey].items;
          }
        }
        
        setObjectFieldValue(JSON.stringify(currentFields, null, 4));
      } catch (error) {
        console.error('Error updating JSON view:', error);
      }
    }
  };

  const handleEnumChange = (key, newEnum) => {
    try {
      if (!newEnum.trim()) {
        setToolData((prevToolData) => {
          const updatedFields = updateField(
            prevToolData.fields,
            key.split("."),
            (field) => ({
              ...field,
              enum: [],
            })
          );
          return {
            ...prevToolData,
            fields: updatedFields,
          };
        });
        return;
      }

      let parsedEnum = newEnum.trim().replace(/'/g, '"');
      if (parsedEnum.startsWith("[") && parsedEnum.endsWith("]")) {
        parsedEnum = JSON.parse(parsedEnum);
      } else {
        toast.error("Invalid format. Expected a JSON array format.");
        return;
      }

      if (!Array.isArray(parsedEnum)) {
        toast.error("Parsed value is not an array.");
        return;
      }

      setToolData((prevToolData) => {
        const updatedFields = updateField(
          prevToolData.fields,
          key.split("."),
          (field) => ({
            ...field,
            enum: parsedEnum.length === 0 ? [] : parsedEnum,
          })
        );
        return {
          ...prevToolData,
          fields: updatedFields,
        };
      });
    } catch (error) {
      toast.error("Failed to update enum: " + error.message);
    }
  };

  const handleSaveFunctionData = () => {
    if (!isEqual(toolData, function_details)) {
      const { _id, ...dataToSend } = toolData;
      dispatch(
        updateFuntionApiAction({
          function_id: functionId,
          dataToSend: dataToSend,
        })
      );
    }
    if (!isEqual(variablesPath, variables_path[functionName] || {})) {
      dispatch(
        updateBridgeVersionAction({
          bridgeId: params.id,
          versionId: params.version,
          dataToSend: { variables_path: { [functionName]: variablesPath } },
        })
      );
    }
    resetModalData();
  };

  const removePreFunction = () => {
    dispatch(updateApiAction(params.id, {
      pre_tools: [],
      version_id: params.version
    })).then(() => {
      closeModal(Model_Name);
    });
  }

  const handleRemoveFunctionFromBridge = () => {
    dispatch(
      updateBridgeVersionAction({
        bridgeId: params.id,
        versionId: params.version,
        dataToSend: {
          functionData: {
            function_id: functionId,
            function_name: functionName,
          },
        },
      })
    ).then(() => {
      closeModal(Model_Name);
    });
  };

  const getNestedFieldValue = (fields, keyParts) => {
    if (!fields || !keyParts) return {};
    
    return keyParts.reduce((currentField, key) => {
      if (!currentField) return {};
      
      if (currentField.type === 'array') {
        return currentField.items?.[key] || {};
      }
      
      if (currentField.type === 'object') {
        return currentField.parameter?.[key] || {};
      }
      
      return currentField[key] || {};
    }, fields);
  };

  const handleToggleChange = (e) => {
    if (e.target.checked) {
      setObjectFieldValue(JSON.stringify(toolData["fields"], undefined, 4));
      setIsTextareaVisible((prev) => !prev);
    } else if (!e.target.checked) {
      try {
        const updatedField = JSON.parse(objectFieldValue);
        if (typeof updatedField !== "object" || updatedField === null) {
          throw new Error("Invalid JSON format. Please enter a valid object.");
        }
        setToolData((prevToolData) => ({
          ...prevToolData,
          fields: updatedField,
        }));
        setIsTextareaVisible((prev) => !prev);
      } catch (error) {
        toast.error("Invalid JSON format. Please correct the data.");
        console.error("JSON Parsing Error:", error.message);
      }
    } else {
      toast.error("Must be valid json");
    }
  };

  const handleTextFieldChange = () => {
    try {
      const updatedField = JSON.parse(objectFieldValue);
      if (typeof updatedField !== "object" || updatedField === null) {
        throw new Error("Invalid JSON format. Please enter a valid object.");
      }
      setToolData((prevToolData) => ({
        ...prevToolData,
        fields: updatedField,
      }));
    } catch (error) {
      toast.error("Invalid JSON format. Please correct the data.");
      console.error("JSON Parsing Error:", error.message);
    }
  };

  const handleVariablePathChange = (key, value = "") => {
    setVariablesPath((prevVariablesPath) => ({
      ...prevVariablesPath,
      [key]: value || "",
    }));
  };

  const handleOptimizeRawJson = async () => {
    try {
      setIsLoading(true);
      const reqJson = JSON.parse(objectFieldValue);
      const result = await optimizeJsonApi({
        data: {
          example_json: reqJson,
        },
      });
      setObjectFieldValue(JSON.stringify(result?.result, undefined, 4));
    } catch (error) {
      console.error("Optimization Error:", error);
    } finally {
      setIsLoading(false);
    } 
  };

  const generateUniqueParameterName = () => {
    const existingNames = flattenedParameters.map(param => param.key);
    const newParams = existingNames.filter(name => /^new\d+$/.test(name));
    const numbers = newParams.map(name => parseInt(name.replace('new', ''), 10));
    const maxNumber = numbers.length > 0 ? Math.max(...numbers) : 0;
    return `new${maxNumber + 1}`;
  };

  const handleAddParameter = () => {
    const autoGeneratedName = generateUniqueParameterName();
    
    setToolData(prevToolData => {
      const newFields = JSON.parse(JSON.stringify(prevToolData.fields || {}));
      
      newFields[autoGeneratedName] = {
        type: "string",
        description: "",
        enum: [],
        required_params: [],
        parameter: {}
      };

      return {
        ...prevToolData,
        fields: newFields
      };
    });

    if (isTextareaVisible) {
      try {
        const currentFields = JSON.parse(objectFieldValue || '{}');
        currentFields[autoGeneratedName] = {
          type: "string",
          description: "",
          enum: [],
          required_params: [],
          parameter: {}
        };
        setObjectFieldValue(JSON.stringify(currentFields, null, 4));
      } catch (error) {
        console.error("Error updating JSON view:", error);
      }
    }

    toast.success(`Parameter "${autoGeneratedName}" added successfully`);
  };

  const handleDeleteParameter = (paramKey) => {
    const keyParts = paramKey.split(".");

    if (keyParts.length === 1) {
      setToolData(prevToolData => {
        const { [paramKey]: removedField, ...remainingFields } = prevToolData.fields;
        const updatedRequiredParams = (prevToolData.required_params || [])
          .filter(param => param !== paramKey);

        return {
          ...prevToolData,
          fields: remainingFields,
          required_params: updatedRequiredParams
        };
      });

      setVariablesPath(prevPaths => {
        const { [paramKey]: removed, ...remaining } = prevPaths;
        return remaining;
      });

    } else {
      const parentPath = keyParts.slice(0, -1).join(".");
      const fieldToRemove = keyParts[keyParts.length - 1];

      setToolData(prevToolData => {
        const updatedFields = JSON.parse(JSON.stringify(prevToolData.fields));
        let currentLevel = updatedFields;

        for (let i = 0; i < keyParts.length - 1; i++) {
          const part = keyParts[i];
          if (currentLevel[part]) {
            if (currentLevel[part].type === 'array') {
              currentLevel = currentLevel[part].items;
            } else if (currentLevel[part].type === 'object') {
              currentLevel = currentLevel[part].parameter || {};
            } else {
              break;
            }
          }
        }

        if (currentLevel && currentLevel[fieldToRemove]) {
          delete currentLevel[fieldToRemove];
        }

        return {
          ...prevToolData,
          fields: updatedFields
        };
      });

      setVariablesPath(prevPaths => {
        const newPaths = { ...prevPaths };
        delete newPaths[paramKey];
        return newPaths;
      });
    }

    if (isTextareaVisible) {
      try {
        const currentFields = JSON.parse(objectFieldValue);

        if (keyParts.length === 1) {
          delete currentFields[paramKey];
        } else {
          let currentLevel = currentFields;
          for (let i = 0; i < keyParts.length - 1; i++) {
            const part = keyParts[i];
            if (currentLevel[part]) {
              if (currentLevel[part].type === 'array') {
                currentLevel = currentLevel[part].items;
              } else {
                currentLevel = currentLevel[part].parameter || {};
              }
            }
          }

          if (currentLevel) {
            delete currentLevel[keyParts[keyParts.length - 1]];
          }
        }

        setObjectFieldValue(JSON.stringify(currentFields, undefined, 4));
      } catch (error) {
        console.error("Error updating JSON view:", error);
      }
    }
    
    toast.success("Parameter deleted successfully");
  };
   
  const NestedParamComp = ({ nestedParameters, param }) => {
    return (
      <div className="ml-4 mb-2 p-2 bg-base-200 rounded">
        {nestedParameters.length > 0 ? (
          <table className="table table-sm w-full">
            <thead>
              <tr>
                <th>#</th>
                <th>Name</th>
                <th>Type</th>
                <th>Required</th>
                <th>Description</th>
                <th>Enum</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody>
              {nestedParameters.map((nestedParam, i) => {
                const fullPath = `${param.key}.${nestedParam.key}`;
                const nestedField = getNestedFieldValue(toolData.fields, fullPath.split('.'));
                
                return (
                  <tr key={fullPath}>
                    <td>{i + 1}</td>
                    <td>
                      <input
                        type="text"
                        className="input input-bordered input-sm w-32"
                        value={nestedParam.key}
                        onChange={(e) => {
                          const newName = e.target.value;
                          if (newName.trim()) {
                            handleNestedParameterNameChange(param.key, nestedParam.key, newName);
                          }
                        }}
                      />
                    </td>
                    <td>
                      <select
                        className="select select-sm select-bordered"
                        value={nestedField?.type || "string"}
                        onChange={(e) => {
                          const newType = e.target.value;
                          setToolData(prev => {
                            const updatedFields = updateField(
                              prev.fields,
                              fullPath.split('.'),
                              (field) => ({
                                ...field,
                                type: newType,
                                ...(newType === 'object' ? { parameter: field.parameter || {} } : {}),
                                ...(newType === 'array' ? { items: field.items || { type: 'string' } } : {})
                              })
                            );
                            return {
                              ...prev,
                              fields: updatedFields
                            };
                          });
                        }}
                      >
                        {parameterTypes.map((type, idx) => (
                          <option key={idx} value={type}>{type}</option>
                        ))}
                      </select>
                      {nestedField?.type === 'object' && (
                        <NestedParamComp 
                          nestedParameters={getNestedParameters(fullPath)} 
                          param={{ key: fullPath }}
                        />
                      )}
                    </td>
                    <td>
                      <input
                        type="checkbox"
                        className="checkbox"
                        checked={nestedParam.required}
                        onChange={() => {
                          const parentKey = param.key;
                          const paramName = nestedParam.key;
                          
                          setToolData(prev => {
                            const updatedFields = updateField(
                              prev.fields,
                              parentKey.split('.'),
                              (field) => {
                                const updatedRequiredParams = field.required_params || [];
                                const newRequiredParams = updatedRequiredParams.includes(paramName)
                                  ? updatedRequiredParams.filter(p => p !== paramName)
                                  : [...updatedRequiredParams, paramName];
                                
                                return {
                                  ...field,
                                  required_params: newRequiredParams
                                };
                              }
                            );
                            
                            return {
                              ...prev,
                              fields: updatedFields
                            };
                          });
                        }}
                      />
                    </td>
                    <td>
                      <input
                        type="text"
                        className="input input-bordered input-sm"
                        value={nestedField?.description || ""}
                        onChange={(e) => {
                          setToolData(prev => {
                            const updatedFields = updateField(
                              prev.fields,
                              fullPath.split('.'),
                              (field) => ({
                                ...field,
                                description: e.target.value
                              })
                            );
                            return {
                              ...prev,
                              fields: updatedFields
                            };
                          });
                        }}
                      />
                    </td>
                    <td>
                      <input
                        type="text"
                        className="input input-bordered input-sm"
                        value={JSON.stringify(nestedField?.enum || [])}
                        onBlur={(e) => {
                          try {
                            const newEnum = e.target.value.trim();
                            let parsedEnum = [];
                            
                            if (newEnum) {
                              parsedEnum = JSON.parse(newEnum.replace(/'/g, '"'));
                              if (!Array.isArray(parsedEnum)) {
                                throw new Error("Must be an array");
                              }
                            }
                            
                            setToolData(prev => {
                              const updatedFields = updateField(
                                prev.fields,
                                fullPath.split('.'),
                                (field) => ({
                                  ...field,
                                  enum: parsedEnum
                                })
                              );
                              return {
                                ...prev,
                                fields: updatedFields
                              };
                            });
                          } catch (error) {
                            toast.error("Invalid enum format");
                          }
                        }}
                      />
                    </td>
                    <td>
                      <button
                        className="btn btn-xs btn-error"
                        onClick={() => handleDeleteParameter(fullPath)}
                      >
                        <TrashIcon size={14} />
                      </button>
                    </td>
                  </tr>
                );
              })}
            </tbody>
          </table>
        ) : (
          <p className="text-xs italic text-gray-500">No nested parameters yet.</p>
        )}

        <button
          className="btn btn-sm btn-primary mt-2"
          onClick={() => handleAddNestedParameter(param.key)}
        >
          <AddIcon size={14} /> Add Parameter
        </button>
      </div>
    );
  };

  return (
    <dialog id={Model_Name} className="modal">
      <div className="modal-box w-11/12 max-w-6xl">
        <div className="flex flex-row justify-between mb-3">
          <span className="flex flex-row items-center gap-4">
            <h3 className="font-bold text-lg">Configure fields</h3>
            <div className="flex flex-row gap-1">
              <InfoIcon size={16} />
              <span className="label-text-alt">
                Function used in {(function_details?.bridge_ids || [])?.length}{" "}
                bridges, changes may affect all bridges.
              </span>
            </div>
          </span>
          <div className="flex gap-2">
            <button onClick={() => setIsDescriptionEditing(true)} className="btn btn-sm btn-primary">
              <PencilIcon size={16} /> Update Description
            </button>
            <button onClick={() => preFunction ? removePreFunction() : handleRemoveFunctionFromBridge()} className="btn btn-sm btn-error text-white">
              <TrashIcon size={16} /> Remove {preFunction ? "pre-tool" : "tool"}
            </button>
          </div>
        </div>

        {isDescriptionEditing && (
          <div className="mb-4 p-4 border rounded-lg bg-base-100">
            <div className="flex justify-between items-center mb-2">
              <h4 className="font-semibold">Update Function Description</h4>
              <button
                onClick={() => {setIsDescriptionEditing(false); setToolData({ ...toolData, description: function_details?.description })}}
                className="btn btn-sm btn-ghost"
              >
                <CloseIcon size={16} />
              </button>
            </div>
            <textarea
              className="textarea textarea-bordered w-full min-h-24 resize-y"
              placeholder="Enter function description..."
              value={toolData?.description}
              onChange={(e) => setToolData({ ...toolData, description: e.target.value })}
            />
          </div>
        )}

        <div className="flex justify-between items-center">
          {isDataAvailable && (
            <div className="flex items-center text-sm gap-3 mb-4">
              <p>Raw JSON format</p>
              <input
                type="checkbox"
                className="toggle"
                checked={isTextareaVisible}
                onChange={handleToggleChange}
                title="Toggle to edit object parameter"
              />
              {isTextareaVisible && (
                <div className="flex items-center gap-2">
                  <p>Copy tool call format: </p>
                  <CopyIcon
                    size={16}
                    onClick={copyToolCallFormat}
                    className="cursor-pointer"
                  />
                </div>
              )}
            </div>
          )}
          <div>
            {toolData.old_fields && isTextareaVisible && (
              <div className="flex items-center text-sm gap-3">
                <p>Check for old data</p>
                <input
                  type="checkbox"
                  className="toggle"
                  checked={isOldFieldViewTrue}
                  onChange={() => {
                    setIsOldFieldViewTrue((prev) => !prev);
                  }}
                  title="Toggle to edit object parameter"
                />
              </div>
            )}
          </div>
        </div>

        <div className="flex justify-between pl-1">
          <p
            colSpan="3"
            className="flex items-center gap-1 whitespace-nowrap text-xs mb-2"
          >
            <InfoIcon size={16} /> You can change the data in raw json format.
            For more info click{" "}
            <a
              href="/faq/jsonformatdoc"
              target="_blank"
              rel="noopener noreferrer"
              className=" link link-primary underline cursor-pointer"
            >
              here
            </a>
          </p>
          {isTextareaVisible && (
            <p
              className="cursor-pointer label-text capitalize font-medium bg-gradient-to-r from-blue-800 to-orange-600 text-transparent bg-clip-text"
              onClick={handleOptimizeRawJson}
            >
              Optimize Json Format
            </p>
          )}
        </div>
        {!isDataAvailable ? (
          <div className="flex flex-col">
            <p>No Parameters used in the function</p>
          </div>
        ) : !isTextareaVisible ? (
          <div>
            <div className="overflow-x-auto border rounded-md">
              <table className="table">
                <thead>
                  <tr>
                    <th></th>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Required</th>
                    <th>Description</th>
                    <th>Enum: comma separated</th>
                    <th>Fill with AI</th>
                    <th>Value Path: your_path</th>
                    <th>Actions</th>
                  </tr>
                </thead>
                <tbody>
                  {flattenedParameters.map((param, index) => {
                    const currentField = getNestedFieldValue(
                      toolData.fields,
                      param.key.split(".")
                    );
                    const currentType = currentField?.type || param.type || "";
                    const currentDesc = currentField?.description || "";
                    const currentEnum = currentField?.enum || [];
                    const isExpanded = expandedObjects[param.key];
                    const nestedParameters = currentType === "object" ? getNestedParameters(param.key) : [];

                    return (
                      <React.Fragment key={param.key}>
                        <tr>
                          <td>{index + 1}</td>
                          <td>
                            <input
                              type="text"
                              className="input input-bordered input-sm w-32"
                              value={param.key}
                              onChange={(e) => {
                                const success = handleParameterNameChange(param.key, e.target.value);
                                if (!success) e.target.value = param.key;
                              }}
                              placeholder="Parameter name"
                            />
                          </td>
                          <td>
                            <select
                              className="select select-sm select-bordered"
                              value={currentType}
                              onChange={(e) => handleTypeChange(param.key, e.target.value)}
                            >
                              <option value="" disabled>Select parameter type</option>
                              {parameterTypes?.map((type, idx) => (
                                <option key={idx} value={type}>{type}</option>
                              ))}
                            </select>
                          </td>
                          <td>
                            <input
                              type="checkbox"
                              className="checkbox"
                              checked={(() => {
                                const keyParts = param.key.split(".");
                                if (keyParts.length === 1) {
                                  return (toolData.required_params || []).includes(param.key);
                                } else {
                                  const parentKeyParts = keyParts.slice(0, -1);
                                  const nestedField = getNestedFieldValue(toolData.fields, parentKeyParts);
                                  return nestedField?.required_params?.includes(keyParts.at(-1)) || false;
                                }
                              })()}
                              onChange={() => handleRequiredChange(param.key)}
                            />
                          </td>
                          <td>
                            <input
                              type="text"
                              placeholder="Parameter description"
                              className="input input-bordered w-full input-sm"
                              value={currentDesc}
                              disabled={currentType === "object"}
                              onChange={(e) => handleDescriptionChange(param.key, e.target.value)}
                            />
                          </td>
                          <td>
                            <input
                              key={currentEnum}
                              type="text"
                              placeholder="['a','b','c']"
                              className="input input-bordered w-full input-sm"
                              defaultValue={JSON.stringify(currentEnum)}
                              disabled={currentType === "object"}
                              onBlur={(e) => handleEnumChange(param.key, e.target.value)}
                            />
                          </td>
                          <td>
                            <input
                              type="checkbox"
                              className="checkbox"
                              checked={!(param.key in variablesPath)}
                              disabled={preFunction}
                              onChange={() => {
                                const updated = { ...variablesPath };
                                param.key in updated ? delete updated[param.key] : updated[param.key] = "";
                                setVariablesPath(updated);
                              }}
                            />
                          </td>
                          <td>
                            <input
                              type="text"
                              placeholder="name"
                              className="input input-bordered w-full input-sm"
                              value={variablesPath[param.key] || ""}
                              onChange={(e) => handleVariablePathChange(param.key, e.target.value)}
                            />
                          </td>
                          <td>
                            <button
                              className={`input input-bordered w-full input-sm ${preFunction && !variablesPath[param.key] ? "border-red-500" : ""}`}
                              onClick={() => handleDeleteParameter(param.key)}
                              title="Delete parameter"
                            >
                              <TrashIcon size={16} className="text-red-500" />
                            </button>
                          </td>
                        </tr>

                        {currentType === "object" && (
                          <tr>
                            <td colSpan={10} className="bg-base-100 p-0">
                              <div className="ml-4 pl-4 border-l-2 border-gray-200">
                                <button
                                  className="btn btn-xs flex items-center gap-1 m-2"
                                  onClick={() => toggleObjectExpansion(param.key)}
                                >
                                  Parameters
                                  {isExpanded ? <ChevronDownIcon size={14} /> : <ChevronRightIcon size={14} />}
                                </button>

                                {isExpanded && (
                                  <NestedParamComp 
                                    nestedParameters={nestedParameters} 
                                    param={param}
                                  />
                                )}
                              </div>
                            </td>
                          </tr>
                        )}
                      </React.Fragment>
                    );
                  })}
                </tbody>
              </table>
            </div>
          </div>
        ) : (
          <div className={isOldFieldViewTrue ? "flex items-center gap-2" : ""}>
            <textarea
              type="input"
              value={objectFieldValue}
              className="textarea textarea-bordered border w-full min-h-96 resize-y z-[1]"
              onChange={(e) => setObjectFieldValue(e.target.value)}
              onBlur={handleTextFieldChange}
              placeholder="Enter valid JSON object here..."
            />
            {isOldFieldViewTrue && (
              <textarea
                type="text"
                value={
                  toolData?.old_fields
                    ? JSON.stringify(toolData["old_fields"], undefined, 4)
                    : ""
                }
                className="textarea textarea-bordered border w-full min-h-96 resize-y z-[1]"
              />
            )}
          </div>
        )}
        <div className="flex justify-between items-center mb-2 pt-4">
          {isDataAvailable && (
            <div className="flex items-center gap-2">
              <button
                className="btn btn-sm btn-primary"
                onClick={handleAddParameter}
              >
                <AddIcon size={16} /> Add Parameter
              </button>
            </div>
          )}
          <div className="modal-action m-0">
            <form method="dialog" className="flex flex-row gap-2">
              <button className="btn" onClick={handleCloseModal}>
                Close
              </button>

              {isDataAvailable && (
                <button
                  className="btn btn-primary"
                  onClick={handleSaveFunctionData}
                  disabled={!isModified || isLoading}
                >
                  {isLoading && <span className="loading loading-spinner"></span>}
                  Save
                </button>
              )}
            </form>
          </div>
        </div>
      </div>
    </dialog>
  );
}

export default FunctionParameterModal;